* CASE-SENSITIVE para nombres!!
* Trim espacios intermedios de nombres hasta 1!! Tabs tambi√©n espacios!
* LANG: Se permite esto LANG[yaml], LANG[markdown], LANG[html]
* Se podr√≠a hacer tambi√©n: BOOLEAN, NUMBER, NUMBER[float], NUMBER[int32], NUMBER[int64], STRING, TEXT, CHAR[32], VARCHAR[32], UUID, BINARY[base64], BINARY[hex], BINARY[binary] 
* Documentar en 4.* que el nombre con estilo recomendado es 
	xxxx (@namespace): value
	xxxx: value o 
	xxxx: 
* Revisar documentaci√≥n! Cambian cosas!
* Comentarios: eliminar con normalizaci√≥n de espacios, son s√≥lo para el texto "en bruto"
* stxt validate, stxt trim, stxt normalize (igual que trim), stxt validate, stxt import-schema (stxt -is), stxt transform -pdf, stxt import-transform (stxt -it)
* carpeta local del usuario: normalmente /home/nombredeusuario/.stxt o C:\Users\nombredeusuario\.stxt
	./schema:
		dev.stxt.stxt (namespace dev.stxt)
		org.apache.docs.stxt (namespace org.apache.docs)
		com.google.docs.stxt
	./transform
		html
			org.aapache.docs
		yaml
		xml

P√°ginas web
/                 ‚Üí Landing / ‚ÄúSTxT en 1 Minuto‚Äù (visi√≥n r√°pida)
/spec             ‚Üí Spec oficial (core STxT) ‚Äî sintaxis, reglas, gram√°tica
/schema-spec      ‚Üí Spec de schemas ‚Äî validaci√≥n sem√°ntica, ejemplos, uso
/tutorial         ‚Üí Tutorial paso a paso (c√≥mo escribir documentos, con y sin namespace)
/examples         ‚Üí Ejemplos reales / casos de uso
/tools            ‚Üí Parsers disponibles, validadores, playground, c√≥digo fuente
/migration        ‚Üí Gu√≠a de migraci√≥n desde versiones anteriores (si corresponde)
/contribute       ‚Üí C√≥mo contribuir, licencia, contacto, roadmap
/docs/es/         ‚Üí Versi√≥n en espa√±ol de todo lo anterior

STXT: Human-first
STXT: Built for humans. Reliable for machines.
Hacer intro de filosofia
Hacer p√°gina entera filosofia
Nuevo dise√±o de web (azul)
	HEX #005A8E
	Con acentos en:
	#0A6FAE (m√°s claro)
	#E8F4FA (background claro sutil)
Cambiar STxT por STXT

Contactar Amaris!! CMS: partner o patrocinador o colaborador o mentor o soci tecnol√≤gic o impulsora o sponsor o protector
						APADRINAR!! Amaris es el padrino del lenguaje y lo hace crecer, cuida, etc.


# üß© Orden final recomendado (roadmap oficial)

### **FASE 1 ‚Äî n√∫cleo del lenguaje**

1. Parser: 
	Javascript/Typescript
	Python
	Java	
2. Serializador JSON + pretty-printer
3. CLI m√≠nima (en node.js)

### **FASE 2 ‚Äî utilidad real**

4. Validador de schemas
5. Extensi√≥n VSCode
6. Playground

### **FASE 3 ‚Äî ecosistema**

7. Serializadores a otros formatos
8. Generador de documentaci√≥n
9. Linter sem√°ntico








# ‚úÖ **1. Parser oficial (core STXT-SPEC) ‚Äî obligatorio**

El parser es la base para absolutamente todo lo dem√°s.

Debe implementar **100% del STXT-SPEC**:

* indentaci√≥n estricta
* mezcla espacios/tabs prohibida
* nodos `:`
* nodos `>>`
* comentarios fuera de bloques
* normalizaci√≥n (nombres, inline, bloques)
* errores formales

**Lenguajes prioritarios:**

1. **JavaScript / TypeScript**

   * Porque sirve para web, para Node, y para integraciones.
2. **Python**

   * Para automatizaciones, pipelines, IA, APIs.
3. **Java**

   * Importante en enterprise.

Despu√©s: C#, Go, Rust.

**En cada versi√≥n:**

* parsear ‚Üí entregar √°rbol can√≥nico ‚Üí sin validaci√≥n sem√°ntica.

---

# ‚úÖ **2. Serializador (canonical JSON / STxT pretty-print)** ‚Äî imprescindible

Un parser sin serializador no permite test unitarios reproducibles.

Necesitas:

### 2.1. JSON can√≥nico

Basado en lo que ya definiste:

```json
{
  "documents": [
      { "name": "Documento", "namespace": "@x", "children": [...] }
  ]
}
```

* siempre orden estable
* sin espacios sobrantes
* sin claves opcionales vac√≠as

Sirve para:

* comparar dos parsers
* test cross-language
* herramientas de CI

### 2.2. Pretty-printer STxT (opcional pero muy √∫til)

Transforma el √°rbol parseado en STxT formateado uniformemente.

Sirve para:

* estilizar documentos
* editor / extension VSCode
* auto-format

---

# ‚úÖ **3. Validador de schemas (STXT-SCHEMA-SPEC)** ‚Äî muy prioritario

Una vez el parser existe, el validador es el segundo gran pilar.

Debe implementar:

* carga de schemas
* asociaci√≥n por namespace
* tipos (TEXT, NUMBER, BASE64, CODE, etc.)
* cardinalidades
* modo **strict** y modo **non-strict**
* regla 7.1 obligatoria
* errores precisos con l√≠nea y tipo

Este componente es el que transforma STxT en un lenguaje *√∫til para datos reales* (similar a JSON Schema, pero human-first).

---

# ‚úÖ **4. CLI oficial (`stxt`)** ‚Äî alt√≠simo valor pr√°ctico

Una herramienta de l√≠nea de comandos que haga:

* `stxt parse file.stxt` ‚Üí JSON can√≥nico
* `stxt validate file.stxt` ‚Üí aplica schema
* `stxt format file.stxt` ‚Üí pretty-print
* `stxt check file.stxt` ‚Üí lint b√°sico + errores de indentaci√≥n

Esto tambi√©n alimenta:

* CI/CD
* Makefiles
* integraci√≥n con editores
* scripts autom√°ticos

Idealmente escrito en Node.js (cross-platform inmediato) o Rust (portabilidad + velocidad + binarios peque√±os).

---

# ‚úÖ **5. Extensi√≥n VSCode** ‚Äî imprescindible a nivel de adopci√≥n

Incluye:

### M√≠nimo viable:

* coloreado (syntax highlighting)
* plegado de bloques (folding de jerarqu√≠a)
* reconocimiento b√°sico de `:` y `>>`

### Fase 2:

* autocompletado de nombres seg√∫n schema
* validaci√≥n en tiempo real
* tooltip con tipo / cardinalidad
* auto-format

Esta herramienta multiplica la adopci√≥n del lenguaje.

---

# ‚úÖ **6. Playground web**

Una web interactiva:

* editor con STxT a la izquierda
* JSON can√≥nico a la derecha
* validaci√≥n con schema opcional
* indicadores de error en tiempo real

Ideal ejemplo: ‚ÄúJSON Editor Online‚Äù pero para STxT.

Esto es fant√°stico para documentaci√≥n y demos.

---

# ‚úÖ **7. Libraries para serializar STxT a otros formatos (opcional pero √∫til)**

* Serializador STxT ‚Üí **YAML**
* Serializador STxT ‚Üí **JSON**
* Serializador STxT ‚Üí **Markdown**
* Serializador STxT ‚Üí **HTML**

La m√°s esencial es STxT ‚Üí JSON (ya cubierto), pero un par de extras pueden dar mucho valor en algunos contextos.

---

# ‚úÖ **8. Generador de documentaci√≥n a partir de schemas**

Similar a:

* JSON Schema ‚Üí documentaci√≥n HTML
* OpenAPI ‚Üí swagger UI

Con un schema STxT, generar:

* tabla de nodos
* cardinalidades
* tipos
* descripciones
* ejemplos de uso

Muy √∫til para publicar APIs sem√°nticas basadas en STxT.

---

# ‚úÖ **9. Linter sem√°ntico (encima del validador)**

Reglas de estilo:

* evitar nombres ambiguos
* evitar nodos vac√≠os sin necesidad
* recomendaci√≥n sobre orden de nodos
* gu√≠as de estilo corporativo

Esto ya no es esencial para lanzamiento, pero s√≠ √∫til en equipos grandes.

---

